#' Ensemble Clustering Algorithms for Single-Cell Data
#'
#' This function performs ensemble clustering on single-cell RNA-seq data using
#' multiple algorithms including CSPA (Cluster-based Similarity Partitioning Algorithm),
#' MCLA (Meta-CLustering Algorithm), and HGSC (Hypergraph Spectral Clustering).
#'
#' @rdname ensemble_clustering
#' 
#' @param expression_data A matrix or data frame containing the gene expression data.
#'   Rows represent cells and columns represent genes.
#' @param true_labels Optional vector of true cluster labels for validation.
#'   If provided, Adjusted Rand Index (ARI) will be calculated.
#' @param H_matrix A hypergraph matrix generated by \code{generate_all_hypergraphs}.
#'   Must be a list containing matrices H, HH, H_sil, HH_sil, H_ch, HH_ch,
#'   H_db, HH_db, H_ave, HH_ave.
#' @param k Optional integer specifying the number of clusters.
#'   If NULL, optimal k will be estimated automatically.
#' @param ensemble_methods Character vector specifying which ensemble methods to use.
#'   Options include: "CSPA_Hc", "CSPA_Louvain", "CSPA_Leiden", "MCLA_Hc",
#'   "MCLA_Louvain", "MCLA_Leiden", "HGSC".
#'
#' @return A list containing:
#' \describe{
#'   \item{ensemble_clusters}{List of clustering results for each method}
#'   \item{ensemble_ari}{List of ARI values if true_labels provided}
#'   \item{quality_indices}{List of quality indices for each method}
#' }
#'
#' @details
#' The function implements several ensemble clustering algorithms:
#' \itemize{
#'   \item CSPA (Cluster-based Similarity Partitioning Algorithm): Uses hierarchical clustering, Louvain, or Leiden community detection
#'   \item MCLA (Meta-CLustering Algorithm): Meta-clustering approach with hierarchical clustering, Louvain, or Leiden
#'   \item HGSC (Hypergraph Spectral Clustering): Spectral clustering on hypergraphs
#' }
#'
#' Quality indices calculated include:
#' \itemize{
#'   \item Silhouette score
#'   \item Calinski-Harabasz index
#'   \item Davies-Bouldin index
#'   \item Dunn index
#' }
#'
#'
#' @importFrom cluster silhouette
#' @importFrom fpc cluster.stats
#' @importFrom igraph graph_from_adjacency_matrix cluster_louvain cluster_leiden membership
#' @importFrom mclust adjustedRandIndex
#' @importFrom stats kmeans hclust cutree dist
#' @importFrom utils head
#' @importFrom methods new
#' @importFrom SummarizedExperiment assay
#' @importFrom stats as.dist
#'
#'
#' @export
setMethod("ensemble_clustering", "ScEnsemble", 
          function(object,
                   expression_data,
                   true_labels = NULL,
                   H_matrix,
                   k = NULL,
                   ensemble_methods = c("CSPA_Hc", "CSPA_Louvain", "CSPA_Leiden",
                                        "MCLA_Hc", "MCLA_Louvain", "MCLA_Leiden", "HGSC")) {


  expression_data <- as.matrix(assay(object@sce))
  true_labels <- object@annotation
  
  # Retrieve data 
  H_matrix <- object@hypergraphs
  
  # Extract matrices from H_matrix
  H <- H_matrix$H
  HH <- H_matrix$HH
  H_sil <- H_matrix$H_sil
  HH_sil <- H_matrix$HH_sil
  H_ch <- H_matrix$H_ch
  HH_ch <- H_matrix$HH_ch
  H_db <- H_matrix$H_db
  HH_db <- H_matrix$HH_db
  H_ave <- H_matrix$H_ave
  HH_ave <- H_matrix$HH_ave
  
  # Input validation
  if (!is.matrix(expression_data) && !is.data.frame(expression_data)) {
    stop("expression_data must be a matrix or data frame")
  }

  if (!is.list(H_matrix)) {
    stop("H_matrix must be a list containing hypergraph matrices")
  }

  # Validate ensemble methods
  valid_methods <- c("CSPA_Hc", "CSPA_Louvain", "CSPA_Leiden",
                     "MCLA_Hc", "MCLA_Louvain", "MCLA_Leiden", "HGSC")

  if (!all(ensemble_methods %in% valid_methods)) {
    invalid_methods <- setdiff(ensemble_methods, valid_methods)
    stop("Invalid ensemble methods: ", paste(invalid_methods, collapse = ", "))
  }

  # K??meleme kalite indekslerini hesaplayan ana fonksiyon
  calculate_quality_indices <- function(data, clusters, method_name = "") {
    clusters <- as.numeric(factor(clusters))  

    n_clusters <- length(unique(clusters))
    if (n_clusters < 2) {
      warning(sprintf("Method %s produced only %d cluster(s). Skipping quality index calculation.", method_name, n_clusters))
      return(list(silhouette = NA, silhouette_norm = NA,
                  calinski_harabasz = NA, calinski_harabasz_norm = NA,
                  davies_bouldin = NA, davies_bouldin_norm = NA,
                  dunn = NA, dunn_norm = NA))
    }

    dist_matrix <- prepare_distance_matrix(data)

    # Ham skorlar?? hesapla
    silhouette_score <- calculate_silhouette(dist_matrix, clusters, method_name)
    ch_score         <- calculate_calinski_harabasz(dist_matrix, clusters, method_name)
    db_score         <- calculate_davies_bouldin(data, clusters, method_name)
    dunn_score       <- calculate_dunn(dist_matrix, clusters, method_name)

    
    silhouette_norm <- if (!is.na(silhouette_score)) (silhouette_score + 1) / 2 else NA
    db_norm <- if (!is.na(db_score)) 1 / (1 + db_score) else NA
    ch_norm <- if (!is.na(ch_score)) log(1 + ch_score) / (1 + log(1 + ch_score)) else NA
    dunn_norm <- if (!is.na(dunn_score)) dunn_score / (1 + dunn_score) else NA

    list(
      silhouette = silhouette_score, silhouette_norm = silhouette_norm,
      calinski_harabasz = ch_score, calinski_harabasz_norm = ch_norm,
      davies_bouldin = db_score, davies_bouldin_norm = db_norm,
      dunn = dunn_score, dunn_norm = dunn_norm)
  }

  prepare_distance_matrix <- function(data) {
    # E??er zaten dist objesi ise do??rudan d??nd??r
    if (inherits(data, "dist")) return(data)

    # E??er kare matrisse (similarity veya distance olabilir)
    if (is.matrix(data) && nrow(data) == ncol(data)) {
      diagonal_mean <- mean(diag(data), na.rm = TRUE)

      # Diagonal ~1 ise bu similarity matrisidir (??rn. korelasyon, cosine)
      if (diagonal_mean > 0.9) {
        # similarity'den distance: distance = 1 - similarity
        distance_matrix <- 1 - data
        diag(distance_matrix) <- 0
        return(as.dist(distance_matrix))
      } else {
        # Diagonal ~0 ise bu zaten distance olabilir
        return(as.dist(data))
      }
    }

    # Veri ??er??evesi ya da veri matrisi ise (ham veri)
    if (is.data.frame(data) || is.matrix(data)) {
      return(dist(data, method = "euclidean"))
    }

    stop("Data format not recognized. Please provide a data.frame, matrix, or dist object.")
  }


  # Silhouette skoru
  calculate_silhouette <- function(dist_matrix, clusters, method_name) {
    tryCatch({
      mean(cluster::silhouette(clusters, dist_matrix)[, 3])
    }, error = function(e) {
      warning(sprintf("Silhouette failed for %s: %s", method_name, e$message))
      NA
    })
  }

  # Calinski-Harabasz skoru
  calculate_calinski_harabasz <- function(dist_matrix, clusters, method_name) {
    tryCatch({
      cluster.stats(dist_matrix, clusters)$ch
    }, error = function(e) {
      warning(sprintf("Calinski-Harabasz failed for %s: %s", method_name, e$message))
      NA
    })
  }

  # Dunn skoru
  calculate_dunn <- function(dist_matrix, clusters, method_name) {
    tryCatch({
      cluster.stats(dist_matrix, clusters)$dunn
    }, error = function(e) {
      warning(sprintf("Dunn failed for %s: %s", method_name, e$message))
      NA
    })
  }

  # Davies-Bouldin skoru
  calculate_davies_bouldin <- function(data, clusters, method_name) {
    tryCatch({
      if (inherits(data, "dist")) return(NA)
      manual_davies_bouldin(as.matrix(data), clusters)
    }, error = function(e) {
      warning(sprintf("Davies-Bouldin failed for %s: %s", method_name, e$message))
      NA
    })
  }

  # Manuel Davies-Bouldin hesaplay??c??
  manual_davies_bouldin <- function(data, clusters) {
    clusters <- as.numeric(factor(clusters))  
    unique_clusters <- unique(clusters)
    n_clusters <- length(unique_clusters)

    centers <- t(sapply(unique_clusters, function(k) colMeans(data[clusters == k, , drop = FALSE])))
    within_scatter <- sapply(unique_clusters, function(k) {
      pts <- data[clusters == k, , drop = FALSE]
      if (nrow(pts) < 2) return(0)
      mean(sqrt(rowSums((pts - matrix(colMeans(pts), nrow(pts), ncol(data), byrow = TRUE))^2)))
    })

    between_distances <- as.matrix(dist(centers))

    db_index <- sapply(1:n_clusters, function(i) {
      max(sapply(setdiff(1:n_clusters, i), function(j) {
        (within_scatter[i] + within_scatter[j]) / between_distances[i, j]
      }))
    })

    mean(db_index)
  }



  results <- list()
  results$ensemble_clusters <- list()
  results$ensemble_ari <- list()
  results$ensemble_quality <- list()  

  # ============================================================
  # B??L??M 4: ENSEMBLE K??MELEME ALGORITMALARI
  # ============================================================
  message("Ensemble clustering algorithms running...")

  # ============================================================
  # CSPA (Cluster-based Similarity Partitioning Algorithm)
  # ============================================================
  if ("CSPA_Hc" %in% ensemble_methods) {
    message("Running CSPA_Hc algorithm...")

    cspa_ensemble <- function(H_weighted) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # CSPA ensemble k??meleme algoritmas??n?? uygular

      # Similarity matrisinden mesafe matrisine d??n????t??r
      D <- 1 - H_weighted

      # Hiyerar??ik k??meleme uygula
      hc <- hclust(as.dist(D), method = "average")

      # Optimal k??me say??s??n?? silhouette y??ntemi ile belirle
      k_range <- 2:10  # Denenecek k de??erleri aral??????
      sil_scores <- numeric(length(k_range))

      for (i in seq_along(k_range)) {
        k_val <- k_range[i]
        clusters <- cutree(hc, k = k_val)

        # Silhouette de??erini hesaplamak i??in en az 2 k??me gerekir
        if (length(unique(clusters)) > 1) {
          sil <- cluster::silhouette(clusters, as.dist(D))
          sil_scores[i] <- mean(sil[, 3])
        } else {
          sil_scores[i] <- 0
        }
      }

      # En y??ksek ortalama silhouette de??erine sahip k'y?? se??
      optimal_k <- k_range[which.max(sil_scores)]

      # Final k??meleri elde et
      final_clusters <- cutree(hc, k = optimal_k)

      return(final_clusters)
    }

    # CSPA algoritmas??n?? farkl?? hypergraph matrislerine uygula
    results$ensemble_clusters$cspa_hc <- list(
      standard = cspa_ensemble(HH),
      silhouette = cspa_ensemble(HH_sil),
      ch = cspa_ensemble(HH_ch),
      db = cspa_ensemble(HH_db),
      average = cspa_ensemble(HH_ave)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$cspa_hc <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$cspa$standard, "CSPA_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$cspa$silhouette, "CSPA_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$cspa$ch, "CSPA_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$cspa$db, "CSPA_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$cspa$average, "CSPA_average")
    )

    # E??er ger??ek etiketler verilmi??se ARI (Adjusted Rand Index) de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$cspa_hc <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa$average)
      )
    }
  }

  # ============================================================
  # CSPA with Louvain Community Detection
  # ============================================================
  if ("CSPA_Louvain" %in% ensemble_methods) {
    message("Running CSPA_Louvain algorithm...")

    cspa_louvain_ensemble <- function(H_weighted) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # CSPA ile Louvain topluluk tespitini birle??tiren ensemble k??meleme uygular

      # Similarity matrisinden graf olu??tur
      g <- igraph::graph_from_adjacency_matrix(H_weighted, mode = "undirected", weighted = TRUE)

      # Louvain topluluk tespiti algoritmas??n?? uygula
      louvain_result <- igraph::cluster_louvain(g)

      # K??me atamalar??n?? al
      clusters <- igraph::membership(louvain_result)

      return(clusters)
    }

    # CSPA-Louvain algoritmas??n?? farkl?? hypergraph matrislerine uygula
    results$ensemble_clusters$cspa_louvain <- list(
      standard = cspa_louvain_ensemble(HH),
      silhouette = cspa_louvain_ensemble(HH_sil),
      ch = cspa_louvain_ensemble(HH_ch),
      db = cspa_louvain_ensemble(HH_db),
      average = cspa_louvain_ensemble(HH_ave)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$cspa_louvain <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$cspa_louvain$standard, "CSPA_Louvain_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$cspa_louvain$silhouette, "CSPA_Louvain_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$cspa_louvain$ch, "CSPA_Louvain_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$cspa_louvain$db, "CSPA_Louvain_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$cspa_louvain$average, "CSPA_Louvain_average")
    )

    # E??er ger??ek etiketler verilmi??se ARI de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$cspa_louvain <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_louvain$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_louvain$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_louvain$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_louvain$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_louvain$average)
      )
    }
  }

  # ============================================================
  # CSPA with Leiden Community Detection
  # ============================================================
  if ("CSPA_Leiden" %in% ensemble_methods) {
    message("Running CSPA_Leiden algorithm...")

    cspa_leiden_ensemble <- function(H_weighted, resolution=1.0) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # CSPA ile Leiden topluluk tespitini birle??tiren ensemble k??meleme uygular

      # Similarity matrisinden graf olu??tur
      g <- igraph::graph_from_adjacency_matrix(H_weighted, mode = "undirected", weighted = TRUE)

      # Leiden topluluk tespiti uygula
      leiden_result <- igraph::cluster_leiden(g, resolution = resolution)

      # K??me atamalar??n?? al
      clusters <- igraph::membership(leiden_result)

      return(clusters)
    }

    # En iyi sonucu verecek resolution parametresini bulmaya ??al????
    optimize_resolution <- function(H_weighted, true_labels) {
      res_range <- seq(0.1, 2.0, by = 0.1)
      ari_scores <- numeric(length(res_range))

      for (i in seq_along(res_range)) {
        clusters <- cspa_leiden_ensemble(H_weighted, resolution = res_range[i])
        ari_scores[i] <- adjustedRandIndex(true_labels, clusters)
      }

      best_res <- res_range[which.max(ari_scores)]
      return(best_res)
    }

    # Her bir hypergraph matrisi i??in ayr?? ayr?? resolution parametresi hesapla
    resolution_params <- list()

    # E??er ger??ek etiketler verilmi??se, her matris i??in resolution parametresini optimize et
    if (!is.null(true_labels)) {
      resolution_params$standard <- optimize_resolution(HH, true_labels)
      resolution_params$silhouette <- optimize_resolution(HH_sil, true_labels)
      resolution_params$ch <- optimize_resolution(HH_ch, true_labels)
      resolution_params$db <- optimize_resolution(HH_db, true_labels)
      resolution_params$average <- optimize_resolution(HH_ave, true_labels)
    } else {
      # Ger??ek etiketler yoksa varsay??lan de??erleri kullan
      resolution_params$standard <- 1.0
      resolution_params$silhouette <- 1.0
      resolution_params$ch <- 1.0
      resolution_params$db <- 1.0
      resolution_params$average <- 1.0
    }

    # CSPA-Leiden algoritmas??n?? farkl?? hypergraph matrislerine, her biri i??in optimize edilmi?? resolution de??erleriyle uygula
    results$ensemble_clusters$cspa_leiden <- list(
      standard = cspa_leiden_ensemble(HH, resolution_params$standard),
      silhouette = cspa_leiden_ensemble(HH_sil, resolution_params$silhouette),
      ch = cspa_leiden_ensemble(HH_ch, resolution_params$ch),
      db = cspa_leiden_ensemble(HH_db, resolution_params$db),
      average = cspa_leiden_ensemble(HH_ave, resolution_params$average)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$cspa_leiden <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$cspa_leiden$standard, "CSPA_Leiden_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$cspa_leiden$silhouette, "CSPA_Leiden_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$cspa_leiden$ch, "CSPA_Leiden_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$cspa_leiden$db, "CSPA_Leiden_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$cspa_leiden$average, "CSPA_Leiden_average")
    )

    # E??er ger??ek etiketler verilmi??se ARI de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$cspa_leiden <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_leiden$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_leiden$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_leiden$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_leiden$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$cspa_leiden$average)
      )
    }
  }

  # ============================================================
  # MCLA (Meta-CLustering Algorithm)
  # ============================================================
  if ("MCLA_Hc" %in% ensemble_methods) {
    message("Running MCLA_Hc algorithm...")

    mcla_ensemble <- function(H_weighted, k=NULL) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # MCLA ensemble k??meleme algoritmas??n?? uygular

      # Hyperedge say??s?? (H'nin s??tun say??s??)
      n_hyperedges <- ncol(H_weighted)

      # Hyperedge'ler aras??nda Jaccard benzerli??i hesapla
      J <- matrix(0, n_hyperedges, n_hyperedges)

      for (i in 1:(n_hyperedges-1)) {
        for (j in (i+1):n_hyperedges) {
          # Jaccard benzerli??i hesapla (kesi??im/birle??im)
          # Boolean operat??rler yerine ger??ek say?? de??erlerini kullan
          intersection <- sum(pmin(H_weighted[, i], H_weighted[, j]))
          union <- sum(pmax(H_weighted[, i], H_weighted[, j]))

          if (union > 0) {
            J[i, j] <- intersection / union
            J[j, i] <- J[i, j]  # Matris simetriktir
          }
        }
      }

      # Mesafe matrisine d??n????t??r
      D <- 1 - J

      # Hyperedge'leri k??meleme
      hc <- hclust(as.dist(D), method = "average")

      # Optimal k??me say??s??n?? silhouette y??ntemi ile belirle
      if (is.null(k)) {
        k_range <- 2:min(10, n_hyperedges-1)  # Denenecek k de??erleri aral??????
        sil_scores <- numeric(length(k_range))

        for (i in seq_along(k_range)) {
          k_val <- k_range[i]
          clusters <- cutree(hc, k = k_val)

          # Silhouette de??erini hesaplamak i??in en az 2 k??me gerekir
          if (length(unique(clusters)) > 1) {
            sil <- cluster::silhouette(clusters, as.dist(D))
            sil_scores[i] <- mean(sil[, 3])
          } else {
            sil_scores[i] <- 0
          }
        }

        # En y??ksek ortalama silhouette de??erine sahip k'y?? se??
        optimal_k <- k_range[which.max(sil_scores)]
      } else {
        optimal_k <- k
      }

      meta_clusters <- cutree(hc, k = optimal_k)

      # Meta-k??meleri birle??tir ve her nesne i??in en ??ok ili??kili k??meyi bul
      n_samples <- nrow(H_weighted)
      cluster_association <- matrix(0, n_samples, optimal_k)

      for (i in 1:optimal_k) {
        meta_cluster_i <- which(meta_clusters == i)
        if (length(meta_cluster_i) > 0) {
          # Bu meta-k??meye ait H s??tunlar??n?? topla
          # H_weighted matrisinin de??erlerini kullan
          cluster_association[, i] <- rowSums(H_weighted[, meta_cluster_i, drop = FALSE])
        }
      }

      # Her nesneyi en y??ksek ili??kiye sahip meta-k??meye ata
      final_clusters <- apply(cluster_association, 1, which.max)

      # K??me etiketlerini rasgele atama yerine 1'den ba??layan ard??????k say??lar olarak d??nd??r
      return(as.integer(final_clusters))
    }

    # MCLA algoritmas??n?? farkl?? hypergraph matrislerine uygula
    # Not: MCLA i??in k parametresi gereklidir
    results$ensemble_clusters$mcla <- list(
      standard = mcla_ensemble(H),
      silhouette = mcla_ensemble(H_sil),
      ch = mcla_ensemble(H_ch),
      db = mcla_ensemble(H_db),
      average = mcla_ensemble(H_ave)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$mcla <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$mcla$standard, "MCLA_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$mcla$silhouette, "MCLA_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$mcla$ch, "MCLA_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$mcla$db, "MCLA_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$mcla$average, "MCLA_average")
    )

    # E??er ger??ek etiketler verilmi??se ARI de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$mcla <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla$average)
      )
    }
  }

  # ============================================================
  # MCLA with Louvain Community Detection
  # ============================================================
  if ("MCLA_Louvain" %in% ensemble_methods) {
    message("Running MCLA_Louvain algorithm...")

    mcla_louvain_ensemble <- function(H_weighted, k = NULL, resolution = 1.0) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # MCLA ile Louvain topluluk tespitini birle??tiren ensemble k??meleme uygular

      # Hyperedge say??s?? (H'nin s??tun say??s??)
      n_hyperedges <- ncol(H_weighted)

      # Hyperedge'ler aras??nda Jaccard benzerli??i hesapla
      J <- matrix(0, n_hyperedges, n_hyperedges)

      for (i in 1:(n_hyperedges-1)) {
        for (j in (i+1):n_hyperedges) {
          # Jaccard benzerli??i hesapla - ger??ek say?? de??erleri i??in
          intersection <- sum(pmin(H_weighted[, i], H_weighted[, j]))
          union <- sum(pmax(H_weighted[, i], H_weighted[, j]))

          if (union > 0) {
            J[i, j] <- intersection / union
            J[j, i] <- J[i, j]  # Matris simetriktir
          }
        }
      }

      # Benzerlik matrisinden graf olu??tur
      g <- igraph::graph_from_adjacency_matrix(J, mode = "undirected", weighted = TRUE)

      # Meta-k??meleme i??in Louvain topluluk tespiti uygula
      louvain_result <- igraph::cluster_louvain(g)
      meta_clusters <- igraph::membership(louvain_result)

      # Bulunan meta-k??me say??s??n?? al
      k_actual <- length(unique(meta_clusters))

      # E??er k belirtilmi??se ve bulunan k??me say??s?? farkl??ysa, uyar?? ver
      if (!is.null(k) && k != k_actual) {
        warning(paste("Louvain algoritmas??", k_actual, "k??me buldu, belirtilen k =", k, "de??erinden farkl??."))
      }

      # Meta-k??meleri birle??tir ve her nesne i??in en ??ok ili??kili k??meyi bul
      n_samples <- nrow(H_weighted)
      cluster_association <- matrix(0, n_samples, k_actual)

      for (i in 1:k_actual) {
        meta_cluster_i <- which(meta_clusters == i)
        if (length(meta_cluster_i) > 0) {
          # Bu meta-k??meye ait H s??tunlar??n?? topla
          cluster_association[, i] <- rowSums(H_weighted[, meta_cluster_i, drop = FALSE])
        }
      }

      # Her nesneyi en y??ksek ili??kiye sahip meta-k??meye ata
      final_clusters <- apply(cluster_association, 1, which.max)

      # K??me etiketlerini ard??????k say??lar olarak d??nd??r
      return(as.integer(final_clusters))
    }

    # MCLA-Louvain algoritmas??n?? farkl?? hypergraph matrislerine uygula
    results$ensemble_clusters$mcla_louvain <- list(
      standard = mcla_louvain_ensemble(H),
      silhouette = mcla_louvain_ensemble(H_sil),
      ch = mcla_louvain_ensemble(H_ch),
      db = mcla_louvain_ensemble(H_db),
      average = mcla_louvain_ensemble(H_ave)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$mcla_louvain <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$mcla_louvain$standard, "MCLA_Louvain_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$mcla_louvain$silhouette, "MCLA_Louvain_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$mcla_louvain$ch, "MCLA_Louvain_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$mcla_louvain$db, "MCLA_Louvain_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$mcla_louvain$average, "MCLA_Louvain_average")
    )

    # E??er ger??ek etiketler verilmi??se ARI de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$mcla_louvain <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_louvain$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_louvain$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_louvain$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_louvain$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_louvain$average)
      )
    }
  }

  # ============================================================
  # MCLA with Leiden Community Detection
  # ============================================================
  if ("MCLA_Leiden" %in% ensemble_methods) {
    message("Running MCLA_Leiden algorithm...")

    mcla_leiden_ensemble <- function(H_weighted, k = NULL, resolution = 1.0) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # MCLA ile Leiden topluluk tespitini birle??tiren ensemble k??meleme uygular

      # Hyperedge say??s?? (H'nin s??tun say??s??)
      n_hyperedges <- ncol(H_weighted)

      # Hyperedge'ler aras??nda Jaccard benzerli??i hesapla
      J <- matrix(0, n_hyperedges, n_hyperedges)

      for (i in 1:(n_hyperedges-1)) {
        for (j in (i+1):n_hyperedges) {
          # Jaccard benzerli??i hesapla
          intersection <- sum(pmin(H_weighted[, i], H_weighted[, j]))
          union <- sum(pmax(H_weighted[, i], H_weighted[, j]))

          if (union > 0) {
            J[i, j] <- intersection / union
            J[j, i] <- J[i, j]  # Matris simetriktir
          }
        }
      }

      # Benzerlik matrisinden graf olu??tur
      g <- igraph::graph_from_adjacency_matrix(J, mode = "undirected", weighted = TRUE)

      # Meta-k??meleme i??in Leiden topluluk tespiti uygula
      leiden_result <- igraph::cluster_leiden(g, resolution = resolution, objective_function = "CPM")
      meta_clusters <- igraph::membership(leiden_result)

      # Bulunan meta-k??me say??s??n?? al
      k_actual <- length(unique(meta_clusters))

      # E??er k belirtilmi??se ve bulunan k??me say??s?? farkl??ysa, uyar?? ver
      if (!is.null(k) && k != k_actual) {
        warning(paste("Leiden algoritmas??", k_actual, "k??me buldu, belirtilen k =", k, "de??erinden farkl??."))
      }

      # Meta-k??meleri birle??tir ve her nesne i??in en ??ok ili??kili k??meyi bul
      n_samples <- nrow(H_weighted)
      cluster_association <- matrix(0, n_samples, k_actual)

      for (i in 1:k_actual) {
        meta_cluster_i <- which(meta_clusters == i)
        if (length(meta_cluster_i) > 0) {
          # Bu meta-k??meye ait H s??tunlar??n?? topla
          cluster_association[, i] <- rowSums(H_weighted[, meta_cluster_i, drop = FALSE])
        }
      }

      # Her nesneyi en y??ksek ili??kiye sahip meta-k??meye ata
      final_clusters <- apply(cluster_association, 1, which.max)

      # K??me etiketlerini ard??????k say??lar olarak d??nd??r
      return(as.integer(final_clusters))
    }

    # Resolution parametresi optimizasyonu i??in fonksiyon
    optimize_resolution_leiden <- function(H_weighted, true_labels) {
      res_range <- seq(0.1, 2.0, by = 0.1)
      ari_scores <- numeric(length(res_range))

      for (i in seq_along(res_range)) {
        clusters <- mcla_leiden_ensemble(H_weighted, resolution = res_range[i])
        ari_scores[i] <- adjustedRandIndex(true_labels, clusters)
      }

      best_res <- res_range[which.max(ari_scores)]
      return(best_res)
    }

    # Her bir hypergraph matrisi i??in ayr?? ayr?? resolution parametresi hesapla
    resolution_params <- list()

    # E??er ger??ek etiketler verilmi??se, her matris i??in resolution parametresini optimize et
    if (!is.null(true_labels)) {
      resolution_params$standard <- optimize_resolution_leiden(H, true_labels)
      resolution_params$silhouette <- optimize_resolution_leiden(H_sil, true_labels)
      resolution_params$ch <- optimize_resolution_leiden(H_ch, true_labels)
      resolution_params$db <- optimize_resolution_leiden(H_db, true_labels)
      resolution_params$average <- optimize_resolution_leiden(H_ave, true_labels)
    } else {
      # Ger??ek etiketler yoksa varsay??lan de??erleri kullan
      resolution_params$standard <- 1.0
      resolution_params$silhouette <- 1.0
      resolution_params$ch <- 1.0
      resolution_params$db <- 1.0
      resolution_params$average <- 1.0
    }

    # MCLA-Leiden algoritmas??n?? farkl?? hypergraph matrislerine uygula
    results$ensemble_clusters$mcla_leiden <- list(
      standard = mcla_leiden_ensemble(H, resolution = resolution_params$standard),
      silhouette = mcla_leiden_ensemble(H_sil, resolution = resolution_params$silhouette),
      ch = mcla_leiden_ensemble(H_ch, resolution = resolution_params$ch),
      db = mcla_leiden_ensemble(H_db, resolution = resolution_params$db),
      average = mcla_leiden_ensemble(H_ave, resolution = resolution_params$average)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$mcla_leiden <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$mcla_leiden$standard, "MCLA_Leiden_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$mcla_leiden$silhouette, "MCLA_Leiden_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$mcla_leiden$ch, "MCLA_Leiden_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$mcla_leiden$db, "MCLA_Leiden_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$mcla_leiden$average, "MCLA_Leiden_average")
    )
    # E??er ger??ek etiketler verilmi??se ARI de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$mcla_leiden <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_leiden$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_leiden$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_leiden$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_leiden$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$mcla_leiden$average)
      )
    }
  }
  # ============================================================
  # Hypergraph Spectral Clustering (HGSC)
  # ============================================================
  if ("HGSC" %in% ensemble_methods) {
    message("Running Hypergraph Spectral Clustering(HGSC) algorithm...")

    hgsc_ensemble <- function(H_weighted, k=NULL) {
      # Bu fonksiyon, a????rl??kl?? bir hypergraph matrisi kullanarak
      # hypergraph spectral k??meleme algoritmas??n?? uygular

      # Hypergraph Laplacian matrisini hesapla
      D_v <- diag(rowSums(H_weighted))  # Vertex derece matrisi
      D_e <- diag(colSums(H_weighted))  # Edge derece matrisi

      # D_v^(-1/2) ve D_e^(-1) hesapla
      D_v_inv_sqrt <- diag(1 / sqrt(diag(D_v)))
      D_e_inv <- diag(1 / diag(D_e))

      # Normalize edilmi?? Laplacian matrisi
      L <- diag(nrow(H_weighted)) - D_v_inv_sqrt %*% H_weighted %*% D_e_inv %*% t(H_weighted) %*% D_v_inv_sqrt

      estimate_optimal_k <- function(L) {
        # Laplacian matrisinin eigen de??erlerini hesapla
        eigen_values <- eigen(L, only.values = TRUE)$values

        # Eigen de??erleri k??????kten b??y????e s??rala
        eigen_values <- sort(eigen_values)

        # Ard??????k eigen de??erler aras??ndaki farklar?? hesapla
        eigen_gaps <- diff(eigen_values)

        # En b??y??k gap'in indeksini bul
        # Bu, optimum k??me say??s??na i??aret eder
        k_est <- which.max(eigen_gaps) + 1

        return(k_est)
      }

      # E??er k de??eri verilmemi??se, eigengap y??ntemiyle tahmin et
      if(is.null(k)) {
        k <- estimate_optimal_k(L)
      }
      # Eigen de??erler ve vekt??rler
      eigen_result <- eigen(L)

      eigenvalues_sorted <- sort(eigen_result$values, index.return = TRUE)
      U <- eigen_result$vectors[, eigenvalues_sorted$ix[1:k]]
      # En k??????k k adet eigen de??ere kar????l??k gelen eigen vekt??rler
      #U <- eigen_result$vectors[, (ncol(eigen_result$vectors) - k + 1):ncol(eigen_result$vectors)]

      # K-means k??meleme
      kmeans_result <- kmeans(U, centers = k, nstart = 20)

      return(kmeans_result$cluster)
    }

    # HGSC algoritmas??n?? farkl?? hypergraph matrislerine uygula
    results$ensemble_clusters$hgsc <- list(
      standard = hgsc_ensemble(HH),
      silhouette = hgsc_ensemble(HH_sil),
      ch = hgsc_ensemble(HH_ch),
      db = hgsc_ensemble(HH_db),
      average = hgsc_ensemble(HH_ave)
    )

    # Kalite indekslerini hesapla
    results$quality_indices$hgsc <- list(
      standard = calculate_quality_indices(HH, results$ensemble_clusters$hgsc$standard, "HGSC_standard"),
      silhouette = calculate_quality_indices(HH_sil, results$ensemble_clusters$hgsc$silhouette, "HGSC_silhouette"),
      ch = calculate_quality_indices(HH_ch, results$ensemble_clusters$hgsc$ch, "HGSC_ch"),
      db = calculate_quality_indices(HH_db, results$ensemble_clusters$hgsc$db, "HGSC_db"),
      average = calculate_quality_indices(HH_ave, results$ensemble_clusters$hgsc$average, "HGSC_average")
    )

    # E??er ger??ek etiketler verilmi??se ARI de??erlerini hesapla
    if (!is.null(true_labels)) {
      results$ensemble_ari$hgsc <- list(
        standard = adjustedRandIndex(true_labels, results$ensemble_clusters$hgsc$standard),
        silhouette = adjustedRandIndex(true_labels, results$ensemble_clusters$hgsc$silhouette),
        ch = adjustedRandIndex(true_labels, results$ensemble_clusters$hgsc$ch),
        db = adjustedRandIndex(true_labels, results$ensemble_clusters$hgsc$db),
        average = adjustedRandIndex(true_labels, results$ensemble_clusters$hgsc$average)
      )
    }
  }

  ensemble_results <- new("EnsembleResults",
                                ensemble_clusters = results$ensemble_clusters,
                                ensemble_ari = results$ensemble_ari,
                                ensemble_quality = results$quality_indices)
  
  
  object@ensemble_results <- ensemble_results
  
  
  return(object)
}
)

